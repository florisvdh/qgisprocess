---
title: "Basic usage of qgisprocess"
author: "Jannes Muenchow"
date: "Last updated: yyyy-mm-dd"
output:
  html_document: 
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Basic usage of qgisprocess}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::knitr}
---

# Setting up the system

**qgisprocess** is basically a wrapper around the standalone command line tool [`qgis_process`](https://github.com/qgis/QGIS-Documentation/issues/5803).
Therefore, you need to have installed QGIS on your system as well as 3rd party providers such as GRASS and SAGA to access and run all geoalgorithms provided through `qgis_process` from within R.
To facilitate using **qgisprocess**, we have created a docker image that already comes with the needed software packages.
You can pull it from dockerhub by running:

```{sh, eval=FALSE}
docker pull geocompr/geocompr:qgis-ext
```

For a more detailed introduction on how to use docker with **qgisprocess** have a look a the corresponding vignette.

# Basic usage

Since **qgisprocess** depends on the command line tool `qgis_process`, it already tries to detect `qgis_process` on your system when it is being attached, and complains if it cannot find it.

```{r}
library("qgisprocess")
```

If you want to find out, how **qgisprocess**  detected `qgis_process`, run `qgis_configure()`.

```{r config}
qgis_configure()
```

Here, `qgis_process` was detected in the PATH variable.
However, `qgis_configure()` first tries if the R option `qgisprocess.path` or the global environment variable `R_QGISPROCESS_PATH` has been set.
This already indicates that you can specify one of these variables in case `qgis_process` has not been installed in one of the most common locations or if there are multiple QGIS versions available (both of which might sometimes happen under Windows).
If this is the case, set `options(qgisprocess.path = '/path/to/qgis_process')` and re-run `qgis_configure()`.
Under Windows make sure to indicate the path to the `qgis_process-qgis.bat` file, e.g.,

```{r win-config, eval=FALSE}
# specify path to QGIS installation on Windows 
options("qgisprocess.path" = "C:/Program Files/QGIS 3.16/bin/qgis_process-qgis.bat")
# or use the QGIS nightly version (if installed via OSGeo4W)
# options("qgisprocess.path" = "C:/OSGeo4W64/bin/qgis_process-qgis-dev.bat")
qgis_configure()
```

Assuming that `qgis_configure()` ran successfully, we can check which QGIS version our system is running:

```{r vers}
qgis_version()
```

Next, let's list all available providers including available 3rd party applications: 

```{r providers}
qgis_providers()
```

This tells us that we can also use the third-party providers GDAL, SAGA and GRASS through the QGIS interface.
To find out about the available geoalgorithms, run:

```{r algs}
algs = qgis_algorithms()
algs
# or use the cached algorithms which have been collected while
# calling library(qgisprocess)
# algs = qgisprocess_cache$algorithms
```

Since we have also installed GRASS and SAGA, nearly 1000 geoalgorithms are at our disposal.
To find out about a specific geoalgorithm and a description of its arguments, use `qgis_show_help()`, e.g.:

```{r help, eval=FALSE}
qgis_show_help("native:buffer")
## Buffer (native:buffer)
## 
## ----------------
## Description
## ----------------
## This algorithm computes a buffer area for all the features in an input layer, using a fixed or dynamic distance.
## 
## The segments parameter controls the number of line segments to use to approximate a quarter circle when creating rounded offsets.
## 
##...
```

```{r, eval=FALSE, echo=FALSE}
# cat(qgis_description("native:buffer"))
# cat(qgis_help_text("native:buffer"))
```

Find out the arguments of a specific geoalgorithm:

```{r args}
qgis_arguments("native:buffer")
```

And finally run it:

```{r buffer}
data("random_points", package = "spDataLarge")
sf::st_crs(random_points) = "EPSG:32717"
out = qgis_run_algorithm("native:buffer", INPUT = random_points, DISTANCE = 50,
                         .quiet = TRUE)
```

As a convenience to the user, `qgis_run_algorithm()` reports all unspecified and automatically chosen arguments.
The `out` object is of class `qgis_result` and contains the path to the output object created by `qgis_process` (when not explicitly setting an output object, **qgisprocess** creates it automatically for you), the used algorithm and input arguments as well as an object`.processx_result` which is especially useful if somethings went wrong.

```{r inspect}
# inspect the out object
class(out)
str(out)
```

To read in the QGIS output and visualize it, we can run:

```{r plot-buffer, message=FALSE}
library("sf")
library("mapview")
# attach QGIS output
# either do it "manually" or ...
buf = read_sf(out$OUTPUT[1])
# use the st_as_sf.qgis_result method
buf = sf::st_as_sf(out)
# plot your result
mapview(buf, col.regions = "blue") + 
  mapview(random_points, col.regions = "red", cex = 3)
```

You can convert each qgis-algorithm into an R function with `qgis_function()`.
So using our buffer example from above, we could also run:

```{r function-creation, eval=FALSE}
# create a function
qgis_buffer = qgis_function("native:buffer")
# run the function
out = qgis_buffer(INPUT = random_points, DISTANCE = 50)
```

As a second example, let's have a look at how to do raster processing running GRASS in the background.
To compute various terrain attributes of a digital elevation model, we can use `grass7:r.slope.aspect`.
We can find out about its arguments again with the help of `qgis_arguments()`

```{r}
qgis_arguments("grass7:r.slope.aspect")
```

```{r slopeaspect, message=FALSE}
library("terra")
# attach digital elevation model from Mt. MongÃ³n (Peru)
dem = rast(system.file("raster/dem.tif", package = "spDataLarge"))

info = qgis_run_algorithm(alg = "grass7:r.slope.aspect",
                          elevation = dem, 
                          .quiet = TRUE)
# just keep the names of output rasters
nms = qgis_outputs("grass7:r.slope.aspect")$name
# read in the output rasters 
r = info[nms] |>
  unlist() |>
  terra::rast() |>
  as.numeric()
names(r) = nms
# plot the output
plot(r)

# another way of doing it
r = lapply(info[nms], \(x) as.numeric(qgis_as_terra(x))) |> 
  rast()
plot(r)
```
